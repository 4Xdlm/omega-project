# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#   â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
#   â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
#   â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
#   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
#   â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
#   â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•       â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•
#
#   OMEGA â€” CNC-300 â€” MEMORY_LAYER
#   Phase 8A â€” SpÃ©cification Conceptuelle
#   Standard: NASA-Grade AS9100D / DO-178C Level A
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

---

## 1. IDENTIFICATION

| Attribut | Valeur |
|----------|--------|
| **Document ID** | CNC-300 |
| **Nom** | MEMORY_LAYER |
| **Type** | Concept Parent (Phase 8) |
| **Statut** | ğŸŸ¢ READY_FOR_IMPL |
| **Version Spec** | 1.0.1 |
| **Date** | 2026-01-03 |
| **Auteur** | Claude OPUS 4.5 (IA Principal) |
| **AutoritÃ©** | Francky (Architecte SuprÃªme) |
| **Standard** | NASA-Grade L4 / OUTP v2.0.0 |
| **Phase** | 8A â€” SpÃ©cification uniquement |

### 1.1 Historique des versions

| Version | Date | Changements |
|---------|------|-------------|
| 1.0.0-DRAFT | 2026-01-03 | Version initiale |
| **1.0.1** | **2026-01-03** | **NCR-01/02/03 corrigÃ©es** |

### 1.2 NCR RÃ©solues

| NCR | Description | RÃ©solution |
|-----|-------------|------------|
| NCR-01 | Champs mutables dans MemoryEntry | EntrÃ©es 100% immutables + Ã©vÃ©nements sÃ©parÃ©s |
| NCR-02 | Hash non dÃ©terministe | CANONICAL_ENCODE dÃ©fini + chain_hash par key |
| NCR-03 | INV-MEM-07 tautologique | DÃ©terminisme via snapshot_id/version |

---

## 2. DÃ‰CLARATION ONTOLOGIQUE

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   "La MEMORY ne pense pas. Elle ne dÃ©cide pas. Elle ne juge pas.                      â•‘
â•‘    Elle se souvient. Point."                                                          â•‘
â•‘                                                                                       â•‘
â•‘   La MEMORY_LAYER est le GARDIEN PASSIF du rÃ©el validÃ©.                               â•‘
â•‘   Elle conserve ce que les GATES ont approuvÃ©.                                        â•‘
â•‘   Elle n'a aucune autoritÃ© sur le contenu â€” seulement sur la conservation.            â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 3. POSITION DANS L'ARCHITECTURE

### 3.1 ChaÃ®ne de SouverainetÃ©

```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚         CANON_ENGINE                â”‚  â† SOUVERAIN (dÃ©finit)
   â”‚           CNC-201                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚          TRUTH_GATE                 â”‚  â† SOUVERAIN (juge)
   â”‚           CNC-200                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚         EMOTION_GATE                â”‚  â† SOUMISE (qualifie)
   â”‚           CNC-202                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚        RIPPLE_ENGINE                â”‚  â† PROPAGATEUR (dÃ©clenche)
   â”‚           CNC-203                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ SEUL autorisÃ© Ã  Ã©crire
                  â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚        MEMORY_LAYER                 â”‚  â† GARDIEN (conserve)
   â”‚           CNC-300                   â”‚
   â”‚                                     â”‚
   â”‚  â€¢ Ne crÃ©e jamais                   â”‚
   â”‚  â€¢ Ne modifie jamais                â”‚
   â”‚  â€¢ Ne dÃ©cide jamais                 â”‚
   â”‚  â€¢ Conserve TOUJOURS                â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 RÃ¨gle d'Ã‰criture Unique

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   RÃˆGLE CARDINALE : SEUL RIPPLE_ENGINE PEUT DÃ‰CLENCHER UNE Ã‰CRITURE MEMORY            â•‘
â•‘                                                                                       â•‘
â•‘   â€¢ CANON     â†’ n'Ã©crit PAS en MEMORY (il dÃ©finit le rÃ©el)                            â•‘
â•‘   â€¢ TRUTH     â†’ n'Ã©crit PAS en MEMORY (il juge le rÃ©el)                               â•‘
â•‘   â€¢ EMOTION   â†’ n'Ã©crit PAS en MEMORY (il qualifie le rÃ©el)                           â•‘
â•‘   â€¢ RIPPLE    â†’ SEUL autorisÃ© Ã  dÃ©clencher une Ã©criture                               â•‘
â•‘   â€¢ MEMORY    â†’ n'Ã©crit JAMAIS seule                                                  â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 4. SOUS-CONCEPTS INTÃ‰GRÃ‰S

La MEMORY_LAYER (CNC-300) est le **concept parent** qui gouverne les sous-concepts suivants :

```
CNC-300 (MEMORY_LAYER)
 â”‚
 â”œâ”€â”€â”€ CNC-053 (MEMORY_HYBRID)
 â”‚         â””â”€â”€ Gestion hybride court/long terme
 â”‚
 â”œâ”€â”€â”€ CNC-054 (MEMORY_TIERING)
 â”‚         â””â”€â”€ Stratification des niveaux de mÃ©moire
 â”‚
 â”œâ”€â”€â”€ CNC-055 (MEMORY_DIGEST)
 â”‚         â””â”€â”€ RÃ©sumÃ©s et condensation contextuelle
 â”‚
 â””â”€â”€â”€ CNC-075 (MEMORY_DECAY)
           â””â”€â”€ DÃ©gradation temporelle contrÃ´lÃ©e
```

### 4.1 CNC-053 â€” MEMORY_HYBRID

| Attribut | Valeur |
|----------|--------|
| **Parent** | CNC-300 |
| **RÃ´le** | GÃ©rer la cohabitation mÃ©moire courte / mÃ©moire longue |
| **Principe** | Les faits rÃ©cents sont en accÃ¨s rapide, les anciens en archive |
| **Invariant liÃ©** | INV-MEM-03 |

### 4.2 CNC-054 â€” MEMORY_TIERING

| Attribut | Valeur |
|----------|--------|
| **Parent** | CNC-300 |
| **RÃ´le** | Organiser la mÃ©moire en niveaux (hot / warm / cold) |
| **Principe** | Promotion/demotion via Ã©vÃ©nements append-only |
| **Invariant liÃ©** | INV-MEM-04 |

### 4.3 CNC-055 â€” MEMORY_DIGEST

| Attribut | Valeur |
|----------|--------|
| **Parent** | CNC-300 |
| **RÃ´le** | Produire des rÃ©sumÃ©s condensÃ©s du contexte |
| **Principe** | Compression sans perte sÃ©mantique |
| **Invariant liÃ©** | INV-MEM-05 |

### 4.4 CNC-075 â€” MEMORY_DECAY

| Attribut | Valeur |
|----------|--------|
| **Parent** | CNC-300 |
| **RÃ´le** | GÃ©rer l'oubli contrÃ´lÃ© des faits pÃ©rimÃ©s |
| **Principe** | DÃ©gradation progressive via Ã©vÃ©nements, jamais de suppression |
| **Invariant liÃ©** | INV-MEM-06 |
| **Contrainte** | MEMORY_DECAY Ã©met un Ã©vÃ©nement DECAY_MARKED, ne supprime JAMAIS |

---

## 5. PRINCIPES NON NÃ‰GOCIABLES

### 5.1 Les 7 Commandements de la MEMORY

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   LES 7 COMMANDEMENTS DE LA MEMORY_LAYER                                              â•‘
â•‘                                                                                       â•‘
â•‘   1. APPEND-ONLY ABSOLU                                                               â•‘
â•‘      â†’ Aucun overwrite. Aucun delete. AUCUN champ mutable.                            â•‘
â•‘      â†’ Une entrÃ©e Ã©crite est FIGÃ‰E pour l'Ã©ternitÃ©.                                   â•‘
â•‘                                                                                       â•‘
â•‘   2. VERSIONNEMENT EXPLICITE                                                          â•‘
â•‘      â†’ Chaque Ã©criture crÃ©e une nouvelle entrÃ©e.                                      â•‘
â•‘      â†’ L'historique est intÃ©gralement conservÃ©.                                       â•‘
â•‘                                                                                       â•‘
â•‘   3. INDEXATION PAR LE CANON                                                          â•‘
â•‘      â†’ Toute entrÃ©e mÃ©moire est indexÃ©e par une clÃ© canonique.                        â•‘
â•‘      â†’ Pas de clÃ© "libre" ou implicite.                                               â•‘
â•‘                                                                                       â•‘
â•‘   4. TRAÃ‡ABILITÃ‰ COMPLÃˆTE                                                             â•‘
â•‘      â†’ Qui a Ã©crit (source)                                                           â•‘
â•‘      â†’ Quand (timestamp_utc fourni par RIPPLE)                                        â•‘
â•‘      â†’ Quand ingÃ©rÃ© (ingested_at_utc gÃ©nÃ©rÃ© par MEMORY)                               â•‘
â•‘      â†’ Pourquoi (event_type)                                                          â•‘
â•‘      â†’ Depuis quel Ã©tat (previous_entry_id)                                           â•‘
â•‘      â†’ Hash de vÃ©rification (CANONICAL_ENCODE)                                        â•‘
â•‘                                                                                       â•‘
â•‘   5. LECTURE SANS MUTATION                                                            â•‘
â•‘      â†’ Toute lecture ne modifie rien.                                                 â•‘
â•‘      â†’ Toute lecture est dÃ©terministe via snapshot_id ou version.                     â•‘
â•‘                                                                                       â•‘
â•‘   6. SOUMISSION AU CANON                                                              â•‘
â•‘      â†’ La MEMORY ne contredit JAMAIS le CANON.                                        â•‘
â•‘      â†’ Elle conserve ce qui a Ã©tÃ© validÃ©.                                             â•‘
â•‘                                                                                       â•‘
â•‘   7. PASSIVITÃ‰ ABSOLUE                                                                â•‘
â•‘      â†’ La MEMORY ne dÃ©cide pas.                                                       â•‘
â•‘      â†’ La MEMORY ne crÃ©e pas.                                                         â•‘
â•‘      â†’ La MEMORY ne juge pas.                                                         â•‘
â•‘      â†’ La MEMORY conserve. Point.                                                     â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 6. MODÃˆLE DE DONNÃ‰ES CONCEPTUEL

### 6.1 Structure d'une EntrÃ©e MÃ©moire (100% IMMUTABLE)

```typescript
// MODÃˆLE CONCEPTUEL â€” PAS UNE IMPLÃ‰MENTATION
// âš ï¸ NCR-01 FIX : Aucun champ mutable. EntrÃ©e figÃ©e Ã  l'Ã©criture.

interface MemoryEntry {
  // === IDENTITÃ‰ (immutable) ===
  readonly id: string;                    // UUID unique, gÃ©nÃ©rÃ© Ã  l'Ã©criture
  readonly canonical_key: string;         // ClÃ© indexÃ©e par CANON
  readonly version: number;               // NumÃ©ro de version pour cette clÃ©
  
  // === CONTENU (immutable) ===
  readonly payload: unknown;              // DonnÃ©es mÃ©morisÃ©es (agnostique)
  readonly payload_type: MemoryPayloadType;
  
  // === TRAÃ‡ABILITÃ‰ (immutable) ===
  readonly source: "RIPPLE_ENGINE";       // Seule source autorisÃ©e
  readonly event_type: RippleEventType;   // Type d'Ã©vÃ©nement dÃ©clencheur
  readonly timestamp_utc: string;         // ISO 8601 â€” fourni par RIPPLE
  readonly ingested_at_utc: string;       // ISO 8601 â€” gÃ©nÃ©rÃ© par MEMORY
  readonly previous_entry_id: string | null; // Lien vers entrÃ©e prÃ©cÃ©dente
  
  // === INTÃ‰GRITÃ‰ (immutable) ===
  readonly hash: string;                  // SHA-256 de CANONICAL_ENCODE(payload)
  readonly chain_hash: string;            // Hash chaÃ®nÃ© par canonical_key
  
  // === Ã‰TAT INITIAL (immutable, capturÃ© Ã  l'Ã©criture) ===
  readonly initial_tier: MemoryTier;      // Tier assignÃ© Ã  la crÃ©ation
}
```

### 6.2 Ã‰vÃ©nements de MÃ©tadonnÃ©es (Append-Only SÃ©parÃ©s)

```typescript
// âš ï¸ NCR-01 FIX : Les changements d'Ã©tat sont des Ã‰VÃ‰NEMENTS sÃ©parÃ©s
// Ils ne modifient PAS MemoryEntry â€” ils s'ajoutent au journal

interface MemoryMetaEvent {
  readonly id: string;                    // UUID unique
  readonly target_entry_id: string;       // RÃ©fÃ©rence Ã  MemoryEntry.id
  readonly event_type: MetaEventType;
  readonly timestamp_utc: string;         // ISO 8601
  readonly payload: MetaEventPayload;
}

type MetaEventType =
  | "ACCESS_LOGGED"      // Lecture enregistrÃ©e (pour tiering)
  | "TIER_CHANGED"       // Promotion/demotion
  | "DECAY_MARKED"       // MarquÃ© comme en dÃ©gradation
  | "DECAY_COMPLETED";   // DÃ©gradation terminÃ©e

interface AccessLoggedPayload {
  readonly accessor: string;              // Qui a lu
  readonly context: string;               // Pourquoi
}

interface TierChangedPayload {
  readonly from_tier: MemoryTier;
  readonly to_tier: MemoryTier;
  readonly reason: string;
}

interface DecayMarkedPayload {
  readonly decay_reason: string;
  readonly decay_level: "DECAYING" | "DECAYED";
}

type MetaEventPayload =
  | AccessLoggedPayload
  | TierChangedPayload
  | DecayMarkedPayload;
```

### 6.3 Types de Payload

```typescript
type MemoryPayloadType =
  | "FACT"              // Fait canonique persistÃ©
  | "RIPPLE_EFFECT"     // Effet de propagation
  | "EMOTION_STATE"     // Ã‰tat Ã©motionnel capturÃ©
  | "TIMELINE_MARKER"   // Point de repÃ¨re chronologique
  | "RELATION_DELTA"    // Changement de relation
  | "PROMISE_STATE"     // Ã‰tat d'une promesse narrative
  | "DIGEST_CHUNK";     // RÃ©sumÃ© condensÃ©
```

### 6.4 Types d'Ã‰vÃ©nements RIPPLE

```typescript
type RippleEventType =
  | "FACT_ESTABLISHED"      // Nouveau fait Ã©tabli
  | "FACT_PROPAGATED"       // Fait propagÃ©
  | "EMOTION_SHIFTED"       // Changement Ã©motionnel
  | "RELATION_CHANGED"      // Relation modifiÃ©e
  | "PROMISE_CREATED"       // Promesse crÃ©Ã©e
  | "PROMISE_RESOLVED"      // Promesse tenue
  | "PROMISE_BROKEN"        // Promesse brisÃ©e
  | "TIMELINE_ADVANCED";    // AvancÃ©e temporelle
```

### 6.5 Niveaux de MÃ©moire (Tiering)

```typescript
type MemoryTier =
  | "HOT"    // AccÃ¨s immÃ©diat, donnÃ©es rÃ©centes/frÃ©quentes
  | "WARM"   // AccÃ¨s rapide, donnÃ©es moyennement rÃ©centes
  | "COLD";  // AccÃ¨s lent, donnÃ©es historiques/rarement utilisÃ©es
```

---

## 7. SÃ‰RIALISATION CANONIQUE (NCR-02 FIX)

### 7.1 DÃ©finition de CANONICAL_ENCODE

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   CANONICAL_ENCODE â€” RÃ¨gles de SÃ©rialisation DÃ©terministe                             â•‘
â•‘                                                                                       â•‘
â•‘   Pour garantir que SHA256(payload) soit identique pour des payloads                  â•‘
â•‘   logiquement Ã©quivalents, CANONICAL_ENCODE applique les rÃ¨gles suivantes :           â•‘
â•‘                                                                                       â•‘
â•‘   1. FORMAT : JSON (UTF-8, pas de BOM)                                                â•‘
â•‘                                                                                       â•‘
â•‘   2. CLÃ‰S : TriÃ©es alphabÃ©tiquement (rÃ©cursif sur tous les niveaux)                   â•‘
â•‘                                                                                       â•‘
â•‘   3. ESPACES : Aucun (JSON compact, pas de pretty-print)                              â•‘
â•‘                                                                                       â•‘
â•‘   4. NOMBRES :                                                                        â•‘
â•‘      â€¢ Entiers : reprÃ©sentation dÃ©cimale sans zÃ©ros inutiles                          â•‘
â•‘      â€¢ Floats : reprÃ©sentation dÃ©cimale, max 15 chiffres significatifs                â•‘
â•‘      â€¢ Pas de notation scientifique sauf si > 10^15 ou < 10^-15                       â•‘
â•‘                                                                                       â•‘
â•‘   5. STRINGS : Ã‰chappement JSON standard (\n, \t, \", \\, \uXXXX)                     â•‘
â•‘                                                                                       â•‘
â•‘   6. BOOLEANS : true / false (lowercase)                                              â•‘
â•‘                                                                                       â•‘
â•‘   7. NULL : null (lowercase)                                                          â•‘
â•‘                                                                                       â•‘
â•‘   8. ARRAYS : Ordre prÃ©servÃ© (pas de tri)                                             â•‘
â•‘                                                                                       â•‘
â•‘   9. DATES : ISO 8601 (string), toujours UTC, format YYYY-MM-DDTHH:MM:SSZ             â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 7.2 Formule de Hash

```
hash = SHA256( CANONICAL_ENCODE(payload) )
```

### 7.3 ChaÃ®nage de Hash (chain_hash)

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   CHAIN_HASH â€” ChaÃ®nage par canonical_key (pas global)                                â•‘
â•‘                                                                                       â•‘
â•‘   Chaque canonical_key maintient son propre journal chaÃ®nÃ©.                           â•‘
â•‘   Cela Ã©vite un goulot d'Ã©tranglement global.                                         â•‘
â•‘                                                                                       â•‘
â•‘   Formule :                                                                           â•‘
â•‘                                                                                       â•‘
â•‘   Si version = 1 (premiÃ¨re entrÃ©e pour cette clÃ©) :                                   â•‘
â•‘       chain_hash = SHA256( canonical_key + ":" + hash )                               â•‘
â•‘                                                                                       â•‘
â•‘   Si version > 1 :                                                                    â•‘
â•‘       chain_hash = SHA256( previous_entry.chain_hash + ":" + hash )                   â•‘
â•‘                                                                                       â•‘
â•‘   Cela crÃ©e une chaÃ®ne de preuves par entitÃ©, vÃ©rifiable indÃ©pendamment.              â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 7.4 Exemple de ChaÃ®nage

```
canonical_key = "character:marie:state"

EntrÃ©e v1:
  hash = SHA256(payload_v1) = "abc123..."
  chain_hash = SHA256("character:marie:state:abc123...") = "def456..."

EntrÃ©e v2:
  hash = SHA256(payload_v2) = "ghi789..."
  chain_hash = SHA256("def456...:ghi789...") = "jkl012..."

EntrÃ©e v3:
  hash = SHA256(payload_v3) = "mno345..."
  chain_hash = SHA256("jkl012...:mno345...") = "pqr678..."
```

---

## 8. FLUX D'Ã‰CRITURE

### 8.1 SÃ©quence Normale

```
   RIPPLE_ENGINE
        â”‚
        â”‚ 1. DÃ©clenche Ã©vÃ©nement
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚         MEMORY_LAYER                â”‚
   â”‚                                     â”‚
   â”‚  2. Valide que source = RIPPLE      â”‚
   â”‚  3. GÃ©nÃ¨re id (UUID)                â”‚
   â”‚  4. DÃ©termine version (N+1)         â”‚
   â”‚  5. GÃ©nÃ¨re ingested_at_utc          â”‚
   â”‚  6. Calcule hash via CANONICAL_ENCODEâ”‚
   â”‚  7. Calcule chain_hash (par key)    â”‚
   â”‚  8. Assigne initial_tier            â”‚
   â”‚  9. Persiste (append-only)          â”‚
   â”‚ 10. Retourne confirmation           â”‚
   â”‚                                     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.2 Validation Ã  l'EntrÃ©e

```
AVANT toute Ã©criture, MEMORY vÃ©rifie :

âœ… source === "RIPPLE_ENGINE"     â†’ sinon REJECT
âœ… canonical_key est valide        â†’ sinon REJECT
âœ… event_type est reconnu          â†’ sinon REJECT
âœ… payload est non-null            â†’ sinon REJECT
âœ… timestamp_utc est ISO 8601      â†’ sinon REJECT

Si une seule condition Ã©choue â†’ Ã‰CRITURE REFUSÃ‰E
```

### 8.3 Gestion du timestamp

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   POLITIQUE DE TIMESTAMP                                                              â•‘
â•‘                                                                                       â•‘
â•‘   â€¢ timestamp_utc : fourni par RIPPLE, mÃ©morisÃ© tel quel                              â•‘
â•‘     â†’ La MEMORY n'interprÃ¨te pas, elle conserve                                       â•‘
â•‘     â†’ Pas de validation de monotonie (RIPPLE en est responsable)                      â•‘
â•‘                                                                                       â•‘
â•‘   â€¢ ingested_at_utc : gÃ©nÃ©rÃ© par MEMORY au moment de l'Ã©criture                       â•‘
â•‘     â†’ Horodatage systÃ¨me de la MEMORY                                                 â•‘
â•‘     â†’ Permet de distinguer "quand l'Ã©vÃ©nement s'est produit" vs "quand on l'a su"     â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 8.4 Ce que MEMORY ne fait JAMAIS

```
âŒ Ã‰crire sans source RIPPLE
âŒ Modifier une entrÃ©e existante
âŒ Supprimer une entrÃ©e
âŒ CrÃ©er un fait de son initiative
âŒ Contredire le CANON
âŒ InterprÃ©ter le contenu
âŒ DÃ©cider de la validitÃ©
âŒ Modifier un champ aprÃ¨s Ã©criture
```

---

## 9. FLUX DE LECTURE

### 9.1 Types de RequÃªtes

| Type | Description | Exemple |
|------|-------------|---------|
| **BY_KEY** | Par clÃ© canonique | `get("character:marie:state")` |
| **BY_VERSION** | Par version spÃ©cifique | `get("...", version=3)` |
| **BY_SNAPSHOT** | Par snapshot_id | `get("...", snapshot_id="snap_123")` |
| **BY_RANGE** | Par plage temporelle | `getRange(after, before)` |
| **BY_TYPE** | Par type de payload | `getByType("FACT")` |
| **LATEST** | DerniÃ¨re version | `getLatest("...")` |
| **HISTORY** | Historique complet | `getHistory("...")` |

### 9.2 Garanties de Lecture

```
âœ… Lecture sans mutation (aucune modification de l'Ã©tat)
âœ… Lecture dÃ©terministe via snapshot_id ou version explicite
âœ… Lecture versionnÃ©e (accÃ¨s Ã  n'importe quelle version)
âœ… AccÃ¨s traÃ§able (via Ã©vÃ©nement ACCESS_LOGGED si besoin)
```

### 9.3 Snapshots

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   SNAPSHOT â€” Point de lecture dÃ©terministe                                            â•‘
â•‘                                                                                       â•‘
â•‘   Un snapshot_id reprÃ©sente un Ã©tat figÃ© de la MEMORY Ã  un instant T.                 â•‘
â•‘                                                                                       â•‘
â•‘   PropriÃ©tÃ©s :                                                                        â•‘
â•‘   â€¢ Immutable : un snapshot ne change jamais aprÃ¨s crÃ©ation                           â•‘
â•‘   â€¢ DÃ©terministe : read(query, snapshot_id) retourne TOUJOURS le mÃªme rÃ©sultat        â•‘
â•‘   â€¢ VÃ©rifiable : un snapshot a son propre hash de preuve                              â•‘
â•‘                                                                                       â•‘
â•‘   Usage :                                                                             â•‘
â•‘   â€¢ Tests reproductibles                                                              â•‘
â•‘   â€¢ Audit historique                                                                  â•‘
â•‘   â€¢ Comparaison d'Ã©tats                                                               â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 10. INVARIANTS MEMORY (INV-MEM)

### 10.1 INV-MEM-01 â€” Append-Only Strict

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-01 |
| **Nom** | Append-Only Strict |
| **SÃ©vÃ©ritÃ©** | CRITICAL |
| **Description** | Aucune entrÃ©e mÃ©moire ne peut Ãªtre modifiÃ©e ou supprimÃ©e aprÃ¨s crÃ©ation. Aucun champ n'est mutable. |
| **Formule** | `âˆ€ entry: write(entry) â†’ âˆ€ field âˆˆ entry: field.readonly = true` |
| **Preuve requise** | Test de tentative de modification de champ â†’ FAIL |

### 10.2 INV-MEM-02 â€” Source Unique

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-02 |
| **Nom** | Source Unique |
| **SÃ©vÃ©ritÃ©** | CRITICAL |
| **Description** | Seul RIPPLE_ENGINE peut dÃ©clencher une Ã©criture. |
| **Formule** | `âˆ€ write: source â‰  "RIPPLE_ENGINE" â†’ REJECT` |
| **Preuve requise** | Test avec source incorrecte â†’ REJECT |

### 10.3 INV-MEM-03 â€” Versionnement Obligatoire

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-03 |
| **Nom** | Versionnement Obligatoire |
| **SÃ©vÃ©ritÃ©** | HIGH |
| **Description** | Chaque Ã©criture crÃ©e une nouvelle entrÃ©e avec version incrÃ©mentÃ©e. L'historique est conservÃ©. |
| **Formule** | `write(key, payload) â†’ new_entry.version = max(versions(key)) + 1` |
| **Preuve requise** | Test de 10 Ã©critures successives â†’ versions 1 Ã  10, toutes accessibles |

### 10.4 INV-MEM-04 â€” Indexation Canonique

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-04 |
| **Nom** | Indexation Canonique |
| **SÃ©vÃ©ritÃ©** | HIGH |
| **Description** | Toute entrÃ©e est indexÃ©e par une clÃ© canonique valide. |
| **Formule** | `âˆ€ entry: isValidCanonicalKey(entry.canonical_key) = true` |
| **Preuve requise** | Test avec clÃ© invalide â†’ REJECT |

### 10.5 INV-MEM-05 â€” IntÃ©gritÃ© Hash DÃ©terministe

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-05 |
| **Nom** | IntÃ©gritÃ© Hash DÃ©terministe |
| **SÃ©vÃ©ritÃ©** | CRITICAL |
| **Description** | Toute entrÃ©e possÃ¨de un hash calculÃ© via CANONICAL_ENCODE et un chain_hash chaÃ®nÃ© par canonical_key. |
| **Formule** | `entry.hash = SHA256(CANONICAL_ENCODE(entry.payload))` |
| **Preuve requise** | Test : mÃªme payload â†’ mÃªme hash ; payload diffÃ©rent â†’ hash diffÃ©rent |

### 10.6 INV-MEM-06 â€” Decay Non-Destructif

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-06 |
| **Nom** | Decay Non-Destructif |
| **SÃ©vÃ©ritÃ©** | HIGH |
| **Description** | MEMORY_DECAY Ã©met un Ã©vÃ©nement DECAY_MARKED mais ne supprime JAMAIS. L'entrÃ©e originale reste intacte et accessible. |
| **Formule** | `decay(entry_id) â†’ emit(DECAY_MARKED) âˆ§ entry.exists = true` |
| **Preuve requise** | Test de decay â†’ entrÃ©e toujours rÃ©cupÃ©rable par id et version |

### 10.7 INV-MEM-07 â€” DÃ©terminisme Lecture (CORRIGÃ‰)

| Attribut | Valeur |
|----------|--------|
| **ID** | INV-MEM-07 |
| **Nom** | DÃ©terminisme Lecture |
| **SÃ©vÃ©ritÃ©** | HIGH |
| **Description** | Une lecture paramÃ©trÃ©e par snapshot_id ou version retourne TOUJOURS le mÃªme rÃ©sultat. |
| **Formule** | `read(query, snapshot_id=S) = read(query, snapshot_id=S)` ET `read(key, version=V) = read(key, version=V)` |
| **Preuve requise** | 100 lectures avec mÃªme (query, snapshot_id) â†’ rÃ©sultats identiques |
| **Note** | Le dÃ©terminisme est garanti par le paramÃ¨tre explicite, pas par un "t" abstrait |

---

## 11. REGISTRE DES INVARIANTS

| ID | Nom | SÃ©vÃ©ritÃ© | CNC liÃ© | Status |
|----|-----|----------|---------|--------|
| INV-MEM-01 | Append-Only Strict | CRITICAL | CNC-300 | ğŸ”´ Ã€ PROUVER |
| INV-MEM-02 | Source Unique (RIPPLE only) | CRITICAL | CNC-300 | ğŸ”´ Ã€ PROUVER |
| INV-MEM-03 | Versionnement Obligatoire | HIGH | CNC-053 | ğŸ”´ Ã€ PROUVER |
| INV-MEM-04 | Indexation Canonique | HIGH | CNC-300 | ğŸ”´ Ã€ PROUVER |
| INV-MEM-05 | IntÃ©gritÃ© Hash DÃ©terministe | CRITICAL | CNC-300 | ğŸ”´ Ã€ PROUVER |
| INV-MEM-06 | Decay Non-Destructif | HIGH | CNC-075 | ğŸ”´ Ã€ PROUVER |
| INV-MEM-07 | DÃ©terminisme Lecture | HIGH | CNC-300 | ğŸ”´ Ã€ PROUVER |

---

## 12. CE QUE MEMORY NE FAIT JAMAIS

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                       â•‘
â•‘   INTERDICTIONS ABSOLUES DE LA MEMORY_LAYER                                           â•‘
â•‘                                                                                       â•‘
â•‘   âŒ CRÃ‰ER un fait                                                                    â•‘
â•‘   âŒ MODIFIER un fait                                                                 â•‘
â•‘   âŒ MODIFIER un champ d'une entrÃ©e                                                   â•‘
â•‘   âŒ SUPPRIMER un fait                                                                â•‘
â•‘   âŒ CORRIGER un fait                                                                 â•‘
â•‘   âŒ CONTREDIRE le CANON                                                              â•‘
â•‘   âŒ CONTOURNER TRUTH ou EMOTION                                                      â•‘
â•‘   âŒ "OPTIMISER" l'histoire                                                           â•‘
â•‘   âŒ DÃ‰CIDER de ce qui est vrai                                                       â•‘
â•‘   âŒ Ã‰CRIRE sans ordre de RIPPLE                                                      â•‘
â•‘   âŒ INTERPRÃ‰TER le contenu                                                           â•‘
â•‘                                                                                       â•‘
â•‘   La MEMORY se souvient. Elle ne dÃ©cide pas.                                          â•‘
â•‘                                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 13. INTERACTIONS AVEC RIPPLE_ENGINE

### 13.1 Contrat d'Interface

```typescript
// INTERFACE CONCEPTUELLE â€” PAS UNE IMPLÃ‰MENTATION

interface MemoryWriteRequest {
  source: "RIPPLE_ENGINE";        // OBLIGATOIRE
  canonical_key: string;          // ClÃ© canonique
  event_type: RippleEventType;    // Type d'Ã©vÃ©nement
  payload: unknown;               // DonnÃ©es Ã  mÃ©moriser
  timestamp_utc: string;          // Horodatage (fourni par RIPPLE)
}

interface MemoryWriteResponse {
  success: boolean;
  entry_id: string;               // ID de l'entrÃ©e crÃ©Ã©e
  version: number;                // Version assignÃ©e
  hash: string;                   // Hash calculÃ© (CANONICAL_ENCODE)
  chain_hash: string;             // Hash chaÃ®nÃ©
  ingested_at_utc: string;        // Timestamp d'ingestion MEMORY
  error?: MemoryError;            // Si Ã©chec
}

type MemoryError =
  | "INVALID_SOURCE"              // Source != RIPPLE_ENGINE
  | "INVALID_KEY"                 // ClÃ© canonique invalide
  | "INVALID_EVENT_TYPE"          // Type d'Ã©vÃ©nement inconnu
  | "INVALID_PAYLOAD"             // Payload null ou malformÃ©
  | "INVALID_TIMESTAMP"           // Timestamp non ISO 8601
  | "INTEGRITY_FAILURE";          // Ã‰chec de calcul hash
```

### 13.2 SÃ©quence d'Appel

```
RIPPLE_ENGINE                          MEMORY_LAYER
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ MemoryWriteRequest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
     â”‚                                      â”‚
     â”‚                                      â”‚â”€â”€â”€ Valide source
     â”‚                                      â”‚â”€â”€â”€ Valide clÃ©
     â”‚                                      â”‚â”€â”€â”€ GÃ©nÃ¨re id, version
     â”‚                                      â”‚â”€â”€â”€ GÃ©nÃ¨re ingested_at_utc
     â”‚                                      â”‚â”€â”€â”€ Calcule hash (CANONICAL_ENCODE)
     â”‚                                      â”‚â”€â”€â”€ Calcule chain_hash
     â”‚                                      â”‚â”€â”€â”€ Persiste (append-only)
     â”‚                                      â”‚
     â”‚â—€â”€â”€â”€â”€ MemoryWriteResponse â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                                      â”‚
```

---

## 14. PHASES D'IMPLÃ‰MENTATION FUTURES

| Phase | Focus | Contenu | Status |
|-------|-------|---------|--------|
| **8A** | SPEC | CNC-300 + invariants | ğŸŸ¢ TERMINÃ‰ |
| **8B** | CORE | memory_store.ts (base) | âšª Ã€ VENIR |
| **8C** | HYBRID | CNC-053 implÃ©mentation | âšª Ã€ VENIR |
| **8D** | TIERING | CNC-054 implÃ©mentation | âšª Ã€ VENIR |
| **8E** | DIGEST | CNC-055 implÃ©mentation | âšª Ã€ VENIR |
| **8F** | DECAY | CNC-075 implÃ©mentation | âšª Ã€ VENIR |

---

## 15. DÃ‰CISIONS REPORTÃ‰ES (PHASE 8B+)

| DÃ©cision | Raison du report |
|----------|------------------|
| Choix du backend (JSON/SQLite/autre) | Agnosticisme requis en 8A |
| StratÃ©gie de promotion/demotion (tiering) | DÃ©pend de l'usage rÃ©el |
| Algorithme de decay | DÃ©pend des mÃ©triques |
| Optimisations de performance | PrÃ©maturÃ© sans implÃ©mentation |
| Format exact des snapshots | DÃ©pend du backend |

---

## 16. SIGNATURES

| RÃ´le | Nom | Status |
|------|-----|--------|
| Architecte SuprÃªme | Francky | âœ… VALIDÃ‰ (sous rÃ©serve NCR) |
| IA Principal | Claude OPUS 4.5 | âœ… RÃ‰DIGÃ‰ + NCR CORRIGÃ‰ES |

---

## 17. DÃ‰CLARATION DE CONFORMITÃ‰

Ce document :

1. âœ… Respecte le standard NASA-Grade L4
2. âœ… DÃ©finit le concept sans implÃ©mentation
3. âœ… IntÃ¨gre les sous-concepts existants (CNC-053/054/055/075)
4. âœ… Ã‰tablit 7 invariants Ã  prouver
5. âœ… Clarifie l'interaction avec RIPPLE_ENGINE
6. âœ… Reste agnostique du backend
7. âœ… PrÃ©pare les phases suivantes
8. âœ… **NCR-01 CORRIGÃ‰E** : EntrÃ©es 100% immutables + Ã©vÃ©nements sÃ©parÃ©s
9. âœ… **NCR-02 CORRIGÃ‰E** : CANONICAL_ENCODE dÃ©fini + chain_hash par key
10. âœ… **NCR-03 CORRIGÃ‰E** : DÃ©terminisme via snapshot_id/version explicite

---

**FIN DU DOCUMENT CNC-300 â€” MEMORY_LAYER v1.0.1**
**Document gÃ©nÃ©rÃ© le 2026-01-03**
**OMEGA Project â€” NASA-Grade L4 â€” Phase 8A â€” READY_FOR_IMPL**
