/**
 * OMEGA Runner Report v1.0
 * Phase I - NASA-Grade L4 / DO-178C
 *
 * Generates and manages run reports.
 *
 * INVARIANTS:
 * - I-INV-07: Logs append-only
 * - I-INV-08: Writes only to artefacts/runs/**
 *
 * SPEC: RUNNER_SPEC v1.2 §I
 */

import { join } from 'path';
import { existsSync, appendFileSync, mkdirSync } from 'fs';
import type {
  RunResult,
  BatchResult,
  VerifyResult,
  CapsuleResult,
  ExitCode as ExitCodeType,
} from './types';
import { ExitCode, EXIT_CODE_DESCRIPTIONS, FIXED_PATHS, RUN_FILES } from './types';
import { writeRunFile, getRunDirectory, readRunFile } from './run-directory';

// ═══════════════════════════════════════════════════════════════════════════════
// REPORT TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Report format type.
 */
export type ReportFormat = 'markdown' | 'json' | 'text';

/**
 * Report generation options.
 */
export interface ReportOptions {
  readonly format?: ReportFormat;
  readonly includeTimestamp?: boolean;
  readonly includeHashes?: boolean;
  readonly verbose?: boolean;
}

/**
 * Default report options.
 */
export const DEFAULT_REPORT_OPTIONS: Readonly<Required<ReportOptions>> = Object.freeze({
  format: 'markdown',
  includeTimestamp: true,
  includeHashes: true,
  verbose: false,
});

// ═══════════════════════════════════════════════════════════════════════════════
// REPORT FORMATTERS
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Formats exit code with description.
 */
export function formatExitCode(code: ExitCodeType): string {
  const description = EXIT_CODE_DESCRIPTIONS[code] ?? 'Unknown';
  return `${code} (${description})`;
}

/**
 * Formats timestamp for display.
 */
export function formatTimestamp(timestamp: string): string {
  try {
    const date = new Date(timestamp);
    return date.toISOString();
  } catch {
    return timestamp;
  }
}

/**
 * Truncates hash for display.
 */
export function truncateHash(hash: string, length: number = 16): string {
  if (hash.length <= length) return hash;
  return `${hash.slice(0, length)}...`;
}

// ═══════════════════════════════════════════════════════════════════════════════
// RUN REPORT GENERATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Generates run report in markdown format.
 *
 * @param result - Run result
 * @param options - Report options
 * @returns Markdown report content
 */
export function generateRunReportMarkdown(
  result: RunResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const lines: string[] = [];

  lines.push('# Run Report');
  lines.push('');

  // Status section
  lines.push('## Status');
  lines.push('');
  lines.push(`- **Success**: ${result.success ? 'YES' : 'NO'}`);
  lines.push(`- **Exit Code**: ${formatExitCode(result.exitCode)}`);
  if (result.error) {
    lines.push(`- **Error**: ${result.error}`);
  }
  lines.push('');

  // Run info section
  lines.push('## Run Information');
  lines.push('');
  lines.push(`- **Run ID**: ${result.runId || 'N/A'}`);
  lines.push(`- **Run Path**: ${result.runPath || 'N/A'}`);
  if (opts.includeTimestamp) {
    lines.push(`- **Timestamp**: ${formatTimestamp(result.timestamp)}`);
  }
  lines.push('');

  // Hash section
  if (opts.includeHashes && result.runHash) {
    lines.push('## Hashes');
    lines.push('');
    lines.push(`- **Run Hash**: \`${result.runHash}\``);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`Generated by OMEGA Runner v1.0`);

  return lines.join('\n');
}

/**
 * Generates run report in JSON format.
 *
 * @param result - Run result
 * @param options - Report options
 * @returns JSON report content
 */
export function generateRunReportJson(
  result: RunResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const report: Record<string, unknown> = {
    version: '1.0',
    type: 'run_report',
    success: result.success,
    exitCode: result.exitCode,
    exitDescription: EXIT_CODE_DESCRIPTIONS[result.exitCode],
    runId: result.runId,
    runPath: result.runPath,
  };

  if (result.error) {
    report.error = result.error;
  }

  if (opts.includeTimestamp) {
    report.timestamp = result.timestamp;
  }

  if (opts.includeHashes && result.runHash) {
    report.runHash = result.runHash;
  }

  return JSON.stringify(report, null, 2);
}

/**
 * Generates run report in text format.
 *
 * @param result - Run result
 * @param options - Report options
 * @returns Plain text report content
 */
export function generateRunReportText(
  result: RunResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const lines: string[] = [];

  lines.push('OMEGA Run Report');
  lines.push('================');
  lines.push('');
  lines.push(`Status:    ${result.success ? 'PASS' : 'FAIL'}`);
  lines.push(`Exit Code: ${formatExitCode(result.exitCode)}`);
  if (result.error) {
    lines.push(`Error:     ${result.error}`);
  }
  lines.push('');
  lines.push(`Run ID:    ${result.runId || 'N/A'}`);
  lines.push(`Run Path:  ${result.runPath || 'N/A'}`);
  if (opts.includeTimestamp) {
    lines.push(`Timestamp: ${formatTimestamp(result.timestamp)}`);
  }
  if (opts.includeHashes && result.runHash) {
    lines.push(`Run Hash:  ${result.runHash}`);
  }

  return lines.join('\n');
}

/**
 * Generates run report in specified format.
 *
 * @param result - Run result
 * @param options - Report options
 * @returns Report content
 */
export function generateRunReport(
  result: RunResult,
  options: ReportOptions = {}
): string {
  const format = options.format ?? DEFAULT_REPORT_OPTIONS.format;

  switch (format) {
    case 'json':
      return generateRunReportJson(result, options);
    case 'text':
      return generateRunReportText(result, options);
    case 'markdown':
    default:
      return generateRunReportMarkdown(result, options);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BATCH REPORT GENERATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Generates batch report in markdown format.
 *
 * @param result - Batch result
 * @param options - Report options
 * @returns Markdown report content
 */
export function generateBatchReportMarkdown(
  result: BatchResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const lines: string[] = [];

  lines.push('# Batch Run Report');
  lines.push('');

  // Summary section
  lines.push('## Summary');
  lines.push('');
  lines.push(`- **Overall Success**: ${result.success ? 'YES' : 'NO'}`);
  lines.push(`- **Exit Code**: ${formatExitCode(result.exitCode)}`);
  lines.push(`- **Total Runs**: ${result.totalRuns}`);
  lines.push(`- **Successful**: ${result.successfulRuns}`);
  lines.push(`- **Failed**: ${result.failedRuns}`);
  lines.push('');

  // Individual runs section
  if (result.runs.length > 0) {
    lines.push('## Individual Runs');
    lines.push('');
    lines.push('| # | Run ID | Status | Exit Code |');
    lines.push('|---|--------|--------|-----------|');

    result.runs.forEach((run, index) => {
      const status = run.success ? 'PASS' : 'FAIL';
      const hash = opts.includeHashes ? ` ${truncateHash(run.runHash)}` : '';
      lines.push(`| ${index + 1} | ${run.runId || 'N/A'} | ${status} | ${run.exitCode}${hash} |`);
    });
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`Generated by OMEGA Runner v1.0`);

  return lines.join('\n');
}

/**
 * Generates batch report in JSON format.
 *
 * @param result - Batch result
 * @param options - Report options
 * @returns JSON report content
 */
export function generateBatchReportJson(
  result: BatchResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const report: Record<string, unknown> = {
    version: '1.0',
    type: 'batch_report',
    success: result.success,
    exitCode: result.exitCode,
    summary: {
      totalRuns: result.totalRuns,
      successfulRuns: result.successfulRuns,
      failedRuns: result.failedRuns,
    },
    runs: result.runs.map(run => ({
      runId: run.runId,
      success: run.success,
      exitCode: run.exitCode,
      ...(opts.includeHashes ? { runHash: run.runHash } : {}),
      ...(opts.includeTimestamp ? { timestamp: run.timestamp } : {}),
      ...(run.error ? { error: run.error } : {}),
    })),
  };

  return JSON.stringify(report, null, 2);
}

/**
 * Generates batch report in specified format.
 *
 * @param result - Batch result
 * @param options - Report options
 * @returns Report content
 */
export function generateBatchReport(
  result: BatchResult,
  options: ReportOptions = {}
): string {
  const format = options.format ?? DEFAULT_REPORT_OPTIONS.format;

  switch (format) {
    case 'json':
      return generateBatchReportJson(result, options);
    case 'markdown':
    default:
      return generateBatchReportMarkdown(result, options);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// VERIFY REPORT GENERATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Generates verify report in markdown format.
 *
 * @param result - Verify result
 * @param runPath - Run path verified
 * @param options - Report options
 * @returns Markdown report content
 */
export function generateVerifyReportMarkdown(
  result: VerifyResult,
  runPath: string,
  options: ReportOptions = {}
): string {
  const lines: string[] = [];

  lines.push('# Verification Report');
  lines.push('');

  // Status section
  lines.push('## Status');
  lines.push('');
  lines.push(`- **Verification**: ${result.success ? 'PASSED' : 'FAILED'}`);
  lines.push(`- **Exit Code**: ${formatExitCode(result.exitCode)}`);
  lines.push(`- **Run Path**: ${runPath}`);
  lines.push('');

  // Stats section
  lines.push('## Statistics');
  lines.push('');
  lines.push(`- **Files Checked**: ${result.filesChecked}`);
  lines.push(`- **Files Valid**: ${result.filesValid}`);
  lines.push('');

  // Mismatches section
  if (result.mismatches.length > 0) {
    lines.push('## Mismatches');
    lines.push('');
    lines.push('| File | Expected | Actual |');
    lines.push('|------|----------|--------|');

    for (const mismatch of result.mismatches) {
      lines.push(`| ${mismatch.file} | ${truncateHash(mismatch.expected)} | ${truncateHash(mismatch.actual)} |`);
    }
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`Generated by OMEGA Runner v1.0`);

  return lines.join('\n');
}

/**
 * Generates verify report in JSON format.
 *
 * @param result - Verify result
 * @param runPath - Run path verified
 * @param options - Report options
 * @returns JSON report content
 */
export function generateVerifyReportJson(
  result: VerifyResult,
  runPath: string,
  options: ReportOptions = {}
): string {
  const report = {
    version: '1.0',
    type: 'verify_report',
    success: result.success,
    exitCode: result.exitCode,
    runPath,
    statistics: {
      filesChecked: result.filesChecked,
      filesValid: result.filesValid,
    },
    mismatches: result.mismatches.map(m => ({
      file: m.file,
      expected: m.expected,
      actual: m.actual,
    })),
  };

  return JSON.stringify(report, null, 2);
}

/**
 * Generates verify report in specified format.
 *
 * @param result - Verify result
 * @param runPath - Run path verified
 * @param options - Report options
 * @returns Report content
 */
export function generateVerifyReport(
  result: VerifyResult,
  runPath: string,
  options: ReportOptions = {}
): string {
  const format = options.format ?? DEFAULT_REPORT_OPTIONS.format;

  switch (format) {
    case 'json':
      return generateVerifyReportJson(result, runPath, options);
    case 'markdown':
    default:
      return generateVerifyReportMarkdown(result, runPath, options);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// CAPSULE REPORT GENERATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Generates capsule report in markdown format.
 *
 * @param result - Capsule result
 * @param options - Report options
 * @returns Markdown report content
 */
export function generateCapsuleReportMarkdown(
  result: CapsuleResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const lines: string[] = [];

  lines.push('# Capsule Report');
  lines.push('');

  // Status section
  lines.push('## Status');
  lines.push('');
  lines.push(`- **Success**: ${result.success ? 'YES' : 'NO'}`);
  lines.push(`- **Exit Code**: ${formatExitCode(result.exitCode)}`);
  lines.push('');

  // Capsule info section
  lines.push('## Capsule Information');
  lines.push('');
  lines.push(`- **Capsule Path**: ${result.capsulePath || 'N/A'}`);
  lines.push(`- **File Count**: ${result.fileCount}`);
  lines.push(`- **Total Bytes**: ${result.totalBytes.toLocaleString()}`);
  lines.push('');

  // Hash section
  if (opts.includeHashes && result.capsuleHash) {
    lines.push('## Hashes');
    lines.push('');
    lines.push(`- **Capsule Hash**: \`${result.capsuleHash}\``);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`Generated by OMEGA Runner v1.0`);

  return lines.join('\n');
}

/**
 * Generates capsule report in JSON format.
 *
 * @param result - Capsule result
 * @param options - Report options
 * @returns JSON report content
 */
export function generateCapsuleReportJson(
  result: CapsuleResult,
  options: ReportOptions = {}
): string {
  const opts = { ...DEFAULT_REPORT_OPTIONS, ...options };
  const report: Record<string, unknown> = {
    version: '1.0',
    type: 'capsule_report',
    success: result.success,
    exitCode: result.exitCode,
    capsulePath: result.capsulePath,
    fileCount: result.fileCount,
    totalBytes: result.totalBytes,
  };

  if (opts.includeHashes && result.capsuleHash) {
    report.capsuleHash = result.capsuleHash;
  }

  return JSON.stringify(report, null, 2);
}

/**
 * Generates capsule report in specified format.
 *
 * @param result - Capsule result
 * @param options - Report options
 * @returns Report content
 */
export function generateCapsuleReport(
  result: CapsuleResult,
  options: ReportOptions = {}
): string {
  const format = options.format ?? DEFAULT_REPORT_OPTIONS.format;

  switch (format) {
    case 'json':
      return generateCapsuleReportJson(result, options);
    case 'markdown':
    default:
      return generateCapsuleReportMarkdown(result, options);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// REPORT I/O
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Writes report to run directory.
 *
 * @param runPath - Run directory path
 * @param content - Report content
 * @returns true if written successfully
 */
export function writeReportToRun(runPath: string, content: string): boolean {
  try {
    const runDir = getRunDirectory(runPath);
    if (!runDir.exists) {
      return false;
    }

    writeRunFile(runDir, RUN_FILES.REPORT, content);
    return true;
  } catch {
    return false;
  }
}

/**
 * Reads report from run directory.
 *
 * @param runPath - Run directory path
 * @returns Report content or null
 */
export function readReportFromRun(runPath: string): string | null {
  const runDir = getRunDirectory(runPath);
  return readRunFile(runDir, RUN_FILES.REPORT);
}

// ═══════════════════════════════════════════════════════════════════════════════
// LOG OPERATIONS (I-INV-07: Append-Only)
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Log entry structure.
 */
export interface LogEntry {
  readonly timestamp: string;
  readonly level: 'INFO' | 'WARN' | 'ERROR';
  readonly message: string;
  readonly runId?: string;
  readonly exitCode?: ExitCodeType;
}

/**
 * Formats log entry for output.
 *
 * @param entry - Log entry
 * @returns Formatted log line
 */
export function formatLogEntry(entry: LogEntry): string {
  const parts = [
    `[${entry.timestamp}]`,
    `[${entry.level}]`,
    entry.runId ? `[${entry.runId}]` : '',
    entry.message,
    entry.exitCode !== undefined ? `(exit: ${entry.exitCode})` : '',
  ];

  return parts.filter(p => p).join(' ');
}

/**
 * Appends log entry to log file.
 * I-INV-07: Append-only operation.
 *
 * @param logPath - Path to log file
 * @param entry - Log entry
 */
export function appendLog(logPath: string, entry: LogEntry): void {
  const line = formatLogEntry(entry) + '\n';

  // Create directory if needed
  const dir = join(logPath, '..');
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  // Append-only write
  appendFileSync(logPath, line, 'utf-8');
}

/**
 * Creates log entry from run result.
 *
 * @param result - Run result
 * @returns Log entry
 */
export function createLogEntryFromRun(result: RunResult): LogEntry {
  return {
    timestamp: result.timestamp,
    level: result.success ? 'INFO' : 'ERROR',
    message: result.success ? 'Run completed successfully' : `Run failed: ${result.error ?? 'Unknown error'}`,
    runId: result.runId,
    exitCode: result.exitCode,
  };
}

/**
 * Creates log entry from verify result.
 *
 * @param result - Verify result
 * @param runPath - Run path
 * @param timestamp - Verification timestamp
 * @returns Log entry
 */
export function createLogEntryFromVerify(
  result: VerifyResult,
  runPath: string,
  timestamp: string
): LogEntry {
  return {
    timestamp,
    level: result.success ? 'INFO' : 'ERROR',
    message: result.success
      ? `Verification passed for ${runPath}`
      : `Verification failed: ${result.mismatches.length} mismatches`,
    exitCode: result.exitCode,
  };
}
